"""
server.ts生成用テンプレート
"""

from typing import List, Dict
from models import CSharpClass, EndpointInfo
from .base import BaseTemplate


class ServerTemplate(BaseTemplate):
    """server.ts生成用テンプレート（GETエンドポイントのみ）"""

    def __init__(self, value_object_types: set[str], class_map: Dict[str, CSharpClass]):
        super().__init__(value_object_types)
        self.class_map = class_map

    def get_header(self) -> str:
        return """// Auto-generated by api-generator.py
// Do not edit manually
// Server-side fetch functions for Next.js Server Components

const BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5000';

/**
 * サーバーサイド用のfetch関数（共通処理）
 */
async function serverFetch<T>(url: string): Promise<T> {
  const response = await fetch(url, {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
    },
    cache: 'no-store', // Next.js: 常に最新のデータを取得
  });

  if (!response.ok) {
    throw new Error(`Failed to fetch: ${response.statusText}`);
  }

  return response.json();
}

import type {"""

    def generate(self, endpoints: List[EndpointInfo]) -> str:
        """
        完全なserver.tsの内容を生成（GETエンドポイントのみ）

        Args:
            endpoints: エンドポイント情報のリスト

        Returns:
            server.tsの完全な内容
        """
        # GETエンドポイントのみをフィルタ
        get_endpoints = [ep for ep in endpoints if ep.method == "GET"]

        lines = [self.get_header()]

        # 型インポートを生成
        lines.extend(self._generate_type_imports(get_endpoints))
        lines.append("")

        # コントローラー別にサーバ関数を生成
        by_controller = self._group_by_controller(get_endpoints)
        for controller, eps in sorted(by_controller.items()):
            lines.append(f"// {controller.capitalize()} Server Functions")
            for ep in eps:
                lines.extend(self._generate_server_function(ep))
                lines.append("")

        return self._join_lines(lines)

    def _generate_type_imports(self, endpoints: List[EndpointInfo]) -> List[str]:
        """型インポートセクションを生成"""
        all_types = set()
        for ep in endpoints:
            if ep.request_type and ep.request_type != "void":
                all_types.add(ep.request_type)
            if ep.response_type and ep.response_type != "void":
                all_types.add(ep.response_type)

        lines = []
        for type_name in sorted(all_types):
            lines.append(f"  {type_name},")
        lines.append("} from './types';")

        return lines

    def _generate_server_function(self, ep: EndpointInfo) -> List[str]:
        """個別のサーバ関数を生成"""
        lines = []

        func_name = self._to_camel_case(ep.function_name)
        request_type = ep.request_type or "void"
        response_type = ep.response_type or "void"

        # パスパラメータを検出
        path_params = self._extract_path_params(ep.path)

        # パスパラメータがある場合、テンプレートリテラルを使用
        if path_params:
            url_path = ep.path
            for param in path_params:
                camel_param = self._to_camel_case(param) if param else param

                # リクエストクラスがある場合、プロパティ名を確認
                if request_type in self.class_map:
                    req_class = self.class_map[request_type]
                    prop_names = [self._to_camel_case(prop.name) for prop in req_class.properties]

                    if camel_param == 'id':
                        if 'id' in prop_names:
                            camel_param = 'id'
                        else:
                            id_like = [p for p in prop_names if p.endswith('Id')]
                            if len(id_like) == 1:
                                camel_param = id_like[0]
                            else:
                                # ValueObject型から候補を動的に生成 (ArticleId -> articleId)
                                candidates = [self._to_camel_case(vo_type) for vo_type in self.value_object_types if vo_type.endswith('Id')]
                                for candidate in candidates:
                                    if candidate in prop_names:
                                        camel_param = candidate
                                        break
                url_path = url_path.replace(f'{{{param}}}', f'${{params.{camel_param}}}')
            url_expression = f"`{url_path}`"
        else:
            url_expression = f"'{ep.path}'"

        # 関数シグネチャ
        if request_type == "void":
            lines.append(f"export async function {func_name}(): Promise<{response_type}> {{")
        else:
            lines.append(f"export async function {func_name}(params: {request_type}): Promise<{response_type}> {{")

        # URLの構築
        if path_params and request_type != "void":
            # パスパラメータがある場合: url_expressionは`/api/articles/${params.id}`のような形式
            # バッククォートを除去して、BASE_URLと結合
            url_path = url_expression.strip('`')
            lines.append(f"  const url = `${{BASE_URL}}{url_path}`;")
        elif request_type != "void":
            # クエリパラメータを構築
            url_path = url_expression.strip("'")
            lines.append(f"  const url = new URL('{url_path}', BASE_URL);")
            lines.append("  Object.entries(params).forEach(([key, value]) => {")
            lines.append("    if (value !== undefined && value !== null) {")
            lines.append("      url.searchParams.append(key, String(value));")
            lines.append("    }")
            lines.append("  });")
        else:
            # パラメータなし
            url_path = url_expression.strip("'")
            lines.append(f"  const url = `${{BASE_URL}}{url_path}`;")

        # 共通のfetch関数を呼び出し
        lines.append("")
        if request_type != "void" and not path_params:
            lines.append(f"  return serverFetch<{response_type}>(url.toString());")
        else:
            lines.append(f"  return serverFetch<{response_type}>(url);")
        lines.append("}")

        return lines
