"""
TypeScript生成用のテンプレート定義
"""

# types.tsのヘッダー
TYPES_HEADER = """// Auto-generated by api-generator.py
// Do not edit manually
"""

# endpoints.tsのヘッダー
ENDPOINTS_HEADER = """// Auto-generated by api-generator.py
// Do not edit manually

import { apiClient } from './client';
import type {"""

# hooks.tsのヘッダー
HOOKS_HEADER = """// Auto-generated by api-generator.py
// Do not edit manually

import { useMutation, useQuery, useQueryClient, type UseMutationOptions, type UseQueryOptions } from '@tanstack/react-query';"""

# server.tsのヘッダー
SERVER_HEADER = """// Auto-generated by api-generator.py
// Do not edit manually
// Server-side fetch functions for Next.js Server Components

import type {"""


def generate_interface_declaration(class_name: str, has_properties: bool) -> str:
    """インターフェース宣言を生成"""
    if not has_properties:
        return f"// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface {class_name} {{"
    return f"export interface {class_name} {{"


def generate_property_declaration(prop_name: str, ts_type: str, is_optional: bool) -> str:
    """プロパティ宣言を生成"""
    camel_name = prop_name[0].lower() + prop_name[1:]
    optional = "?" if is_optional else ""
    return f"  {camel_name}{optional}: {ts_type};"


def generate_api_function(func_name: str, request_type: str, response_type: str, 
                          http_method: str, url_expression: str, 
                          path_params: list, send_body: bool) -> list:
    """API関数を生成"""
    lines = []
    
    if request_type == "void":
        lines.append(f"  {func_name}: async (): Promise<{response_type}> => {{")
        if http_method == "DELETE":
            lines.append(f"    await apiClient.delete({url_expression});")
        elif http_method == "GET":
            lines.append(f"    const response = await apiClient.get<{response_type}>({url_expression});")
            lines.append("    return response;")
        else:
            lines.append(f"    const response = await apiClient.{http_method.lower()}<{response_type}>({url_expression});")
            lines.append("    return response;")
    else:
        lines.append(f"  {func_name}: async (data: {request_type}): Promise<{response_type}> => {{")
        if http_method == "DELETE":
            lines.append(f"    await apiClient.delete({url_expression});")
        elif http_method == "GET":
            if path_params:
                lines.append(f"    const response = await apiClient.get<{response_type}>({url_expression});")
            else:
                lines.append(f"    const response = await apiClient.get<{response_type}>({url_expression}, {{ params: data }});")
            lines.append("    return response;")
        else:
            if send_body:
                lines.append(f"    const response = await apiClient.{http_method.lower()}<{response_type}>({url_expression}, data);")
            else:
                lines.append(f"    const response = await apiClient.{http_method.lower()}<{response_type}>({url_expression});")
            lines.append("    return response;")
    
    lines.append("  },")
    return lines


def generate_query_hook(hook_name: str, func_name: str, controller: str, 
                        request_type: str, return_type: str) -> list:
    """Query hookを生成"""
    lines = []
    
    if request_type == "void":
        lines.append(f"export function {hook_name}(options?: Omit<UseQueryOptions<{return_type}>, 'queryKey' | 'queryFn'>) {{")
        lines.append(f"  return useQuery<{return_type}>({{")
        lines.append(f"    queryKey: queryKeys.{controller}.{func_name},")
        lines.append(f"    queryFn: () => {controller}Api.{func_name}(),")
        lines.append("    ...options,")
        lines.append("  });")
        lines.append("}")
    else:
        lines.append(f"export function {hook_name}(params: {request_type}, options?: Omit<UseQueryOptions<{return_type}>, 'queryKey' | 'queryFn'>) {{")
        lines.append(f"  return useQuery<{return_type}>({{")
        lines.append(f"    queryKey: [...queryKeys.{controller}.{func_name}, params],")
        lines.append(f"    queryFn: () => {controller}Api.{func_name}(params),")
        lines.append("    ...options,")
        lines.append("  });")
        lines.append("}")
    
    return lines


def generate_mutation_hook(hook_name: str, func_name: str, controller: str,
                           request_type: str, response_type: str) -> list:
    """ミューテーションフックを生成"""
    lines = []

    if request_type == "void":
        # request_type が void の場合は引数なし
        lines = [
            f"export function {hook_name}(options?: UseMutationOptions<{response_type}, Error, {request_type}>) {{",
            "  const queryClient = useQueryClient();",
            f"  return useMutation<{response_type}, Error, {request_type}>({{",
            f"    mutationFn: () => {controller}Api.{func_name}(),",
            "    onSuccess: (...args) => {",
            f"      queryClient.invalidateQueries({{ queryKey: ['{controller}'] }});",
            "      options?.onSuccess?.(...args);",
            "    },",
            "    ...options,",
            "  });",
            "}",
        ]
    else:
        lines = [
            f"export function {hook_name}(options?: UseMutationOptions<{response_type}, Error, {request_type}>) {{",
            "  const queryClient = useQueryClient();",
            f"  return useMutation<{response_type}, Error, {request_type}>({{",
            f"    mutationFn: (data) => {controller}Api.{func_name}(data),",
            "    onSuccess: (...args) => {",
            f"      queryClient.invalidateQueries({{ queryKey: ['{controller}'] }});",
            "      options?.onSuccess?.(...args);",
            "    },",
            "    ...options,",
            "  });",
            "}",
        ]
    return lines


def generate_server_function(func_name: str, request_type: str, response_type: str,
                             url_expression: str, path_params: list) -> list:
    """Server-side fetch関数を生成"""
    lines = []

    # 関数シグネチャ
    if request_type == "void":
        lines.append(f"export async function {func_name}(): Promise<{response_type}> {{")
    else:
        lines.append(f"export async function {func_name}(params: {request_type}): Promise<{response_type}> {{")

    # API URLの構築
    lines.append("  const baseUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5000';")

    # URLの構築（パスパラメータがある場合は置換）
    if path_params and request_type != "void":
        # テンプレートリテラルからfetch用の文字列に変換
        # url_expression が `\`/api/articles/${data.articleId}\`` のような形式なので、
        # これを `\`${baseUrl}/api/articles/${params.articleId}\`` に変換
        url_with_base = url_expression.replace('`', '`${baseUrl}').replace('data.', 'params.')
        lines.append(f"  const url = {url_with_base};")
    elif request_type != "void":
        # クエリパラメータを構築
        lines.append(f"  const url = new URL({url_expression}, baseUrl);")
        lines.append("  Object.entries(params).forEach(([key, value]) => {")
        lines.append("    if (value !== undefined && value !== null) {")
        lines.append("      url.searchParams.append(key, String(value));")
        lines.append("    }")
        lines.append("  });")
        lines.append("  const finalUrl = url.toString();")
    else:
        lines.append(f"  const url = `${{baseUrl}}{url_expression}`.replace(/^`|`$/g, '');")

    # fetchリクエスト
    lines.append("")
    if request_type == "void" or not path_params:
        fetch_url = "url" if request_type == "void" or path_params else "finalUrl"
    else:
        fetch_url = "url"

    lines.append(f"  const response = await fetch({fetch_url}, {{")
    lines.append("    method: 'GET',")
    lines.append("    headers: {")
    lines.append("      'Content-Type': 'application/json',")
    lines.append("    },")
    lines.append("    cache: 'no-store', // Next.js: 常に最新のデータを取得")
    lines.append("  });")
    lines.append("")

    # エラーハンドリング
    lines.append("  if (!response.ok) {")
    lines.append("    throw new Error(`Failed to fetch: ${response.statusText}`);")
    lines.append("  }")
    lines.append("")

    # レスポンスを返す
    lines.append("  return response.json();")
    lines.append("}")

    return lines
